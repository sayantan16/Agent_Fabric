"""
Agent Factory
Dynamically generates intelligent agents using Claude API
"""

from core.registry import RegistryManager
from config import (
    ANTHROPIC_API_KEY,
    CLAUDE_MODEL,
    CLAUDE_TEMPERATURE,
    CLAUDE_MAX_TOKENS,
    CLAUDE_AGENT_GENERATION_PROMPT,
    MIN_AGENT_LINES,
    MAX_AGENT_LINES,
    AGENT_VALIDATION_RULES,
    AGENT_OUTPUT_SCHEMA,
    ALLOWED_IMPORTS,
    GENERATED_AGENTS_DIR,
    PREBUILT_AGENTS_DIR,
)
import os
import sys
import ast
import json
import traceback
from typing import Dict, List, Optional, Any, Tuple
from anthropic import Anthropic
from core.registry_singleton import get_shared_registry

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))


class AgentFactory:
    """
    Factory for creating intelligent agents powered by Claude.
    Handles code generation, validation, and registration.
    """

    def __init__(self):
        """Initialize the agent factory."""
        self.client = Anthropic(api_key=ANTHROPIC_API_KEY)
        self.registry = get_shared_registry()
        self.generation_history = []

    def create_agent(
        self,
        agent_name: str,
        description: str,
        required_tools: List[str],
        input_description: str,
        output_description: str,
        workflow_steps: Optional[List[str]] = None,
        auto_create_tools: bool = False,
        is_prebuilt: bool = False,
        tags: Optional[List[str]] = None,
    ) -> Dict[str, Any]:
        """
        Create a new agent with Claude.

        Args:
            agent_name: Unique identifier for the agent
            description: Clear description of agent's purpose
            required_tools: List of tools the agent needs
            input_description: Expected input format/type
            output_description: Expected output format/type
            workflow_steps: Optional step-by-step workflow
            auto_create_tools: Whether to auto-create missing tools
            is_prebuilt: Whether this is a prebuilt agent
            tags: Optional categorization tags

        Returns:
            Result dictionary with status and details
        """

        print(f"DEBUG: Creating agent '{agent_name}' with tools: {required_tools}")

        # Validate agent name
        if not self._validate_agent_name(agent_name):
            return {
                "status": "error",
                "message": f"Invalid agent name: {agent_name}. Use lowercase with underscores only.",
            }

        # Check if agent already exists
        if self.registry.agent_exists(agent_name):
            return {
                "status": "exists",
                "message": f"Agent '{agent_name}' already exists and is active",
                "agent": self.registry.get_agent(agent_name),
            }

        # Check for missing tools
        missing_tools = self._check_missing_tools(required_tools)

        print(f"DEBUG: Missing tools for '{agent_name}': {missing_tools}")

        if missing_tools:
            if auto_create_tools:
                # Auto-create missing tools
                tool_creation_results = self._auto_create_tools(missing_tools)
                if not all(r["status"] == "success" for r in tool_creation_results):
                    failed_tools = [
                        t
                        for t, r in zip(missing_tools, tool_creation_results)
                        if r["status"] != "success"
                    ]
                    return {
                        "status": "error",
                        "message": f"Failed to create required tools: {', '.join(failed_tools)}",
                        "missing_tools": failed_tools,
                    }
            else:
                return {
                    "status": "missing_tools",
                    "message": f"Required tools not found: {', '.join(missing_tools)}",
                    "missing_tools": missing_tools,
                    "suggestion": "Set auto_create_tools=True to create them automatically",
                }

        # Generate the agent code
        generation_result = self._generate_agent_code(
            agent_name=agent_name,
            description=description,
            required_tools=required_tools,
            input_description=input_description,
            output_description=output_description,
            workflow_steps=workflow_steps,
        )

        if generation_result["status"] != "success":
            return generation_result

        code = generation_result["code"]

        # Validate the generated code
        validation_result = self._validate_agent_code(code, agent_name)

        if not validation_result["valid"]:
            # Try to fix common issues
            fixed_code = self._attempt_code_fixes(code, validation_result["issues"])
            if fixed_code:
                code = fixed_code
                validation_result = self._validate_agent_code(code, agent_name)

                if not validation_result["valid"]:
                    return {
                        "status": "validation_error",
                        "message": "Generated code failed validation after fixes",
                        "validation_errors": validation_result["issues"],
                        "code": code,
                    }
            else:
                return {
                    "status": "validation_error",
                    "message": "Generated code failed validation",
                    "validation_errors": validation_result["issues"],
                    "code": code,
                }

        # Extract metadata from code
        metadata = self._extract_metadata(code)

        # Register the agent
        registration_result = self.registry.register_agent(
            name=agent_name,
            description=description,
            code=code,
            uses_tools=required_tools,
            input_schema={"type": "any", "description": input_description},
            output_schema=AGENT_OUTPUT_SCHEMA,
            tags=tags or metadata.get("tags", []),
            is_prebuilt=is_prebuilt,
        )

        if registration_result["status"] != "success":
            return registration_result

        # Force all components to reload registry after successful creation
        from core.registry_singleton import RegistrySingleton

        RegistrySingleton().force_reload()
        print(f"DEBUG: Forced registry reload after creating '{agent_name}'")

        # Record generation history
        self.generation_history.append(
            {
                "agent_name": agent_name,
                "timestamp": metadata.get("created_at"),
                "tools_used": required_tools,
                "line_count": len(code.splitlines()),
            }
        )

        return {
            "status": "success",
            "message": f"Agent '{agent_name}' created successfully",
            "agent_name": agent_name,
            "location": registration_result["location"],
            "line_count": registration_result["line_count"],
            "code": code,
        }

    def _generate_agent_code(
        self,
        agent_name: str,
        description: str,
        required_tools: List[str],
        input_description: str,
        output_description: str,
        workflow_steps: Optional[List[str]] = None,
    ) -> Dict[str, Any]:
        """Generate agent code using Claude."""
        # Build tool imports section
        tool_imports = self._build_tool_imports(required_tools)

        # Build agent logic section
        if workflow_steps:
            agent_logic = self._build_workflow_logic(workflow_steps, required_tools)
        else:
            agent_logic = self._build_default_logic(required_tools)

        # Format the prompt
        prompt = CLAUDE_AGENT_GENERATION_PROMPT.format(
            agent_name=agent_name,
            description=description,
            tools=json.dumps(required_tools),
            input_description=input_description,
            output_description=output_description,
            tool_imports=tool_imports,
            agent_logic=agent_logic,
            min_lines=MIN_AGENT_LINES,
            max_lines=MAX_AGENT_LINES,
        )

        try:
            # Call Claude API
            response = self.client.messages.create(
                model=CLAUDE_MODEL,
                temperature=CLAUDE_TEMPERATURE,
                max_tokens=CLAUDE_MAX_TOKENS,
                messages=[{"role": "user", "content": prompt}],
            )

            # Extract code from response
            raw_response = response.content[0].text
            code = self._extract_code_from_response(raw_response)

            if not code:
                print(f"DEBUG: No code extracted from Claude response")
                print(f"DEBUG: Raw Claude response:")
                print(f"{'='*50}")
                print(
                    raw_response[:1000] + "..."
                    if len(raw_response) > 1000
                    else raw_response
                )
                print(f"{'='*50}")
                return {
                    "status": "error",
                    "message": "No valid Python code found in Claude response",
                }

            print(
                f"DEBUG: Successfully extracted {len(code.splitlines())} lines of code"
            )
            return {"status": "success", "code": code}

        except Exception as e:
            return {
                "status": "error",
                "message": f"Claude API error: {str(e)}",
                "traceback": traceback.format_exc(),
            }

    def _validate_agent_code(self, code: str, agent_name: str) -> Dict[str, Any]:
        """
        Comprehensive validation of agent code.

        Args:
            code: Python code to validate
            agent_name: Expected agent name

        Returns:
            Validation result with issues if any
        """
        issues = []

        # Check syntax
        try:
            tree = ast.parse(code)
        except SyntaxError as e:
            return {"valid": False, "issues": [f"Syntax error: {str(e)}"]}

        # Check structure
        if not tree.body or not isinstance(tree.body[0], ast.FunctionDef):
            issues.append("Code must define a function")
            return {"valid": False, "issues": issues}

        func_def = tree.body[0]

        # Check function name - FIXED: Allow both patterns
        expected_names = [f"{agent_name}_agent", agent_name]
        if func_def.name not in expected_names:
            issues.append(f"Function name must be one of: {expected_names}")

        # Check function parameters
        if not func_def.args.args or func_def.args.args[0].arg != "state":
            issues.append('Function must accept "state" as first parameter')

        # Check for output envelope structure (more flexible)
        has_status = any(word in code for word in ['"status"', "'status'", "status"])
        has_data = any(word in code for word in ['"data"', "'data'", "data"])
        has_metadata = any(
            word in code for word in ['"metadata"', "'metadata'", "metadata"]
        )

        if not has_status:
            issues.append("Missing status field in output")
        if not has_data:
            issues.append("Missing data field in output")
        if not has_metadata:
            issues.append("Missing metadata field in output")

        # Check essential patterns
        essential_patterns = [
            "if 'results' not in state",
            "if 'errors' not in state",
            "if 'execution_path' not in state",
            "try:",
            "except Exception as e:",
            "return state",
        ]

        for pattern in essential_patterns:
            if pattern not in code:
                issues.append(f"Missing essential pattern: {pattern}")

        # Check forbidden patterns
        forbidden = ["exec(", "eval(", "__import__", "compile(", "globals(", "locals("]
        for pattern in forbidden:
            if pattern in code:
                issues.append(f"Forbidden pattern found: {pattern}")

        # Check line count
        line_count = len(code.splitlines())
        if line_count < MIN_AGENT_LINES:
            issues.append(
                f"Code too short: {line_count} lines (min: {MIN_AGENT_LINES})"
            )
        elif line_count > MAX_AGENT_LINES:
            issues.append(f"Code too long: {line_count} lines (max: {MAX_AGENT_LINES})")

        result = {"valid": len(issues) == 0, "issues": issues}

        # DEBUG: Show validation details
        if not result["valid"]:
            print(f"DEBUG: Agent validation failed for '{agent_name}'")
            print(f"DEBUG: Validation issues:")
            for i, issue in enumerate(issues, 1):
                print(f"  {i}. {issue}")
            print(f"DEBUG: Generated code preview:")
            print(f"{'='*50}")
            print(code[:500] + "..." if len(code) > 500 else code)
            print(f"{'='*50}")

        return result

    def _attempt_code_fixes(self, code: str, issues: List[str]) -> Optional[str]:
        """
        Attempt to fix common code issues.

        Args:
            code: Code with issues
            issues: List of validation issues

        Returns:
            Fixed code if possible, None otherwise
        """
        fixed_code = code

        # Fix missing return statement
        if any("return state" in issue for issue in issues):
            if not fixed_code.rstrip().endswith("return state"):
                fixed_code = fixed_code.rstrip() + "\n    return state\n"

        # Fix missing state initialization
        if any("results" in issue for issue in issues):
            init_block = """    # Initialize state components
    if 'results' not in state:
        state['results'] = {}
    if 'errors' not in state:
        state['errors'] = []
    if 'execution_path' not in state:
        state['execution_path'] = []
    
"""
            # Insert after function definition
            lines = fixed_code.splitlines()
            for i, line in enumerate(lines):
                if line.strip().startswith("def ") and i + 1 < len(lines):
                    # Find the right place after docstring
                    insert_index = i + 1
                    if i + 1 < len(lines) and (
                        lines[i + 1].strip().startswith('"""')
                        or lines[i + 1].strip().startswith("'''")
                    ):
                        # Skip docstring
                        for j in range(i + 2, len(lines)):
                            if lines[j].strip().endswith('"""') or lines[
                                j
                            ].strip().endswith("'''"):
                                insert_index = j + 1
                                break

                    lines.insert(insert_index, init_block)
                    fixed_code = "\n".join(lines)
                    break

        # Validate the fixed code
        validation = self._validate_agent_code(fixed_code, "temp")
        if validation["valid"] or len(validation["issues"]) < len(issues):
            return fixed_code

        return None

    def _check_missing_tools(self, required_tools: List[str]) -> List[str]:
        """Check which tools are missing from registry."""

        print(f"DEBUG: Checking required tools: {required_tools}")

        missing = []
        for tool in required_tools:
            exists = self.registry.tool_exists(tool)
            print(f"DEBUG: Tool '{tool}' exists: {exists}")
            if not exists:
                missing.append(tool)

        print(f"DEBUG: Missing tools result: {missing}")
        return missing

    def _auto_create_tools(self, tools: List[str]) -> List[Dict[str, Any]]:
        """
        Auto-create missing tools.
        This is a placeholder - in real implementation, would call tool_factory.

        Args:
            tools: List of tool names to create

        Returns:
            List of creation results
        """
        results = []
        for tool_name in tools:
            # This would normally call tool_factory.create_tool()
            # For now, return error
            results.append(
                {
                    "status": "error",
                    "message": f"Auto-creation of tool {tool_name} not implemented",
                }
            )
        return results

    def _build_tool_imports(self, tools: List[str]) -> str:
        """Build the tool import statements."""
        if not tools:
            return "# No tools to import"

        imports = []
        for tool in tools:
            tool_info = self.registry.get_tool(tool)
            if tool_info:
                location = tool_info.get("location", "")
                if "prebuilt" in location:
                    imports.append(f"from prebuilt.tools.{tool} import {tool}")
                else:
                    imports.append(f"from generated.tools.{tool} import {tool}")
            else:
                # If tool doesn't exist yet, assume it will be generated
                imports.append(f"from generated.tools.{tool} import {tool}")

        return "\n    ".join(imports)

    def _build_workflow_logic(self, steps: List[str], tools: List[str]) -> str:
        """Build workflow logic from steps."""
        logic = []
        logic.append("# Execute workflow steps")
        for i, step in enumerate(steps):
            logic.append(f"# Step {i + 1}: {step}")
            # Add placeholder for actual logic
            logic.append(f"# TODO: Implement {step}")

        logic.append("")
        logic.append("# Process with tools")
        for tool in tools:
            logic.append(f"# result = {tool}(input_data)")

        logic.append("")
        logic.append("# Format output")
        logic.append("processed_data = {}")

        return "\n        ".join(logic)

    def _build_default_logic(self, tools: List[str]) -> str:
        """Build default agent logic."""
        logic = []
        logic.append("# Process input data")

        if tools:
            logic.append("# Apply tools to input data")
            logic.append("processed_data = {}")
            for tool in tools:
                logic.append(f"tool_result = {tool}(input_data)")
                logic.append(f"processed_data['{tool}_result'] = tool_result")
        else:
            logic.append("# No tools specified - process input directly")
            logic.append("if isinstance(input_data, str):")
            logic.append(
                "    processed_data = {'processed_text': input_data, 'length': len(input_data)}"
            )
            logic.append("elif isinstance(input_data, dict):")
            logic.append("    processed_data = {'processed_data': input_data}")
            logic.append("else:")
            logic.append(
                "    processed_data = {'result': str(input_data) if input_data else 'No input provided'}"
            )

        return "\n        ".join(logic)

    def _extract_code_from_response(self, response: str) -> Optional[str]:
        """Extract Python code from Claude's response."""
        # Handle markdown code blocks
        if "```python" in response:
            start = response.find("```python") + 9
            end = response.find("```", start)
            if end > start:
                return response[start:end].strip()

        # Handle generic code blocks
        if "```" in response:
            start = response.find("```") + 3
            # Skip language identifier if present
            if response[start : start + 10].strip().startswith(("python", "py")):
                start = response.find("\n", start) + 1
            end = response.find("```", start)
            if end > start:
                code = response[start:end].strip()
                if code.startswith("def "):
                    return code

        # Try to find function definition directly
        if "def " in response:
            start = response.find("def ")
            # Find the end of the function (next def or end of string)
            next_def = response.find("\ndef ", start + 1)
            if next_def > 0:
                return response[start:next_def].strip()
            else:
                return response[start:].strip()

        return None

    def _extract_metadata(self, code: str) -> Dict[str, Any]:
        """Extract metadata from generated code."""
        metadata = {
            "line_count": len(code.splitlines()),
            "has_docstring": '"""' in code or "'''" in code,
            "imports": [],
            "tags": [],
        }

        try:
            tree = ast.parse(code)

            # Extract imports
            for node in ast.walk(tree):
                if isinstance(node, ast.Import):
                    for alias in node.names:
                        metadata["imports"].append(alias.name)
                elif isinstance(node, ast.ImportFrom):
                    if node.module:
                        metadata["imports"].append(node.module)

            # Extract tags from docstring
            if tree.body and isinstance(tree.body[0], ast.FunctionDef):
                docstring = ast.get_docstring(tree.body[0])
                if docstring:
                    # Simple tag extraction from docstring
                    for line in docstring.lower().split("\n"):
                        if "tag" in line or "category" in line:
                            words = line.split()
                            metadata["tags"].extend(
                                [
                                    w.strip(",:")
                                    for w in words
                                    if len(w) > 3 and w.isalpha()
                                ]
                            )

        except:
            pass

        return metadata

    def _validate_agent_name(self, name: str) -> bool:
        """Validate agent name format."""
        import re

        # Allow lowercase letters, numbers, and underscores
        pattern = r"^[a-z][a-z0-9_]*$"
        return bool(re.match(pattern, name))

    def get_generation_history(self) -> List[Dict[str, Any]]:
        """Get history of generated agents."""
        return self.generation_history.copy()

    def regenerate_agent(
        self, agent_name: str, modifications: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Regenerate an existing agent with modifications.

        Args:
            agent_name: Name of agent to regenerate
            modifications: Dict of modifications to apply

        Returns:
            Result of regeneration
        """
        # Get existing agent
        existing = self.registry.get_agent(agent_name)
        if not existing:
            return {"status": "error", "message": f"Agent '{agent_name}' not found"}

        # Apply modifications
        description = modifications.get("description", existing["description"])
        tools = modifications.get("tools", existing["uses_tools"])
        input_desc = modifications.get("input_description", "Modified input")
        output_desc = modifications.get("output_description", "Modified output")

        # Mark old agent as deprecated
        self.registry.agents["agents"][agent_name]["status"] = "deprecated"
        self.registry.save_all()

        # Create new version
        return self.create_agent(
            agent_name=f"{agent_name}_v2",
            description=description,
            required_tools=tools,
            input_description=input_desc,
            output_description=output_desc,
            tags=[f"regenerated_from_{agent_name}"],
        )

    def ensure_agent(
        self, agent_name: str, description: str, required_tools: List[str]
    ) -> Dict[str, Any]:
        """
        Ensure an agent exists - create only if missing (idempotent).
        This is what orchestrator should call.
        """
        # Check if exists
        if self.registry.agent_exists(agent_name):
            return {"status": "exists", "agent": self.registry.get_agent(agent_name)}

        # Simple defaults for Claude
        return self.create_agent(
            agent_name=agent_name,
            description=description,
            required_tools=required_tools,
            input_description="Flexible input - can be string, dict, or list",
            output_description="Standard envelope with data specific to the task",
            auto_create_tools=True,
        )
